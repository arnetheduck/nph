<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>nph</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="open-in.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User guide</li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">3.</strong> Usage</a></li><li class="chapter-item expanded "><a href="style.html"><strong aria-hidden="true">4.</strong> The nph style</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">5.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Developer guide</li><li class="chapter-item expanded "><a href="test.html"><strong aria-hidden="true">6.</strong> Test suite</a></li><li class="chapter-item expanded "><a href="book.html"><strong aria-hidden="true">7.</strong> Updating this book</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nph</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arnetheduck/nph/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>nph</code> is an opinionated source code formatter for the Nim language, aiming to
take the drudgery of manual formatting out of your coding day.</p>
<p>Following the great tradition of <a href="https://github.com/psf/black/"><code>black</code></a>,
<a href="https://prettier.io/"><code>prettier</code></a>, <a href="https://clang.llvm.org/docs/ClangFormat.html"><code>clang-format</code></a>
and other AST-based formatters, it discards existing styling to create a
consistent and beautiful codebase.</p>
<h2 id="priorities"><a class="header" href="#priorities">Priorities</a></h2>
<p><code>nph</code> aims to format code in such way that:</p>
<ul>
<li>it remains semantically unchanged, aka correct (!)
<ul>
<li>the AST is checked for equivalence before writing the formatted code to
disk - on mismatch, the code is left untouched</li>
</ul>
</li>
<li>it remains simple, consistent and pleasant to read
<ul>
<li><em>most</em> code should look as good as or better than its hand-formatted
counterpart</li>
</ul>
</li>
<li>diffs are kept at a minimum
<ul>
<li>diff-inducing constructs such as vertical alignment are avoided, for more
productive merges</li>
<li>formatting the same code again results in no differences</li>
</ul>
</li>
<li>it broadly follows the <a href="https://status-im.github.io/nim-style-guide/">Status Nim style guide</a>
and <a href="https://nim-lang.org/docs/nep1.html">NEP1</a>
<ul>
<li>this is tool aimed at making collaboration easier, with others and your
future self</li>
<li>where NEP1 contradicts itself or these priorities, these priorities have
precedence</li>
</ul>
</li>
</ul>
<p>The formatting rules are loosely derived from other formatters that already have
gone through the journey of debating what &quot;pleasing to read&quot; might mean while
making adaptations for both features and quirks of the Nim parser.</p>
<p>If in doubt, formatting that works well for descriptive identifiers and avoids
putting too much information in a single like will be preferred.</p>
<p>If something breaks the above guidelines, it's <em>likely</em> a bug.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/arnetheduck/nph//edit/master/docs/src/introduction.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="binaries"><a class="header" href="#binaries">Binaries</a></h2>
<p>Download binaries from the <a href="https://github.com/arnetheduck/nph/releases/tag/latest">releases page</a>.</p>
<h2 id="install-via-nimble"><a class="header" href="#install-via-nimble">Install via nimble</a></h2>
<p><code>nph</code> can be compiled or installed using <code>nimble</code> v0.16.4+:</p>
<pre><code class="language-sh"># Install globally
nimble install nph

# Alternatively, clone and build:
git clone https://github.com/arnetheduck/nph.git
cd nph
nimble setup -l
nimble build
</code></pre>
<div id="admonition-nim-version" class="admonition admonish-note">
<div class="admonition-title">
<p>Nim version</p>
<p><a class="admonition-anchor-link" href="installation.html#admonition-nim-version"></a></p>
</div>
<div>
<p><code>nph</code> requires an specific version of <code>nim</code> during the build process since it
reuses parts of the compiler whose API frequently changes - this may lead to
<code>nim</code> itself being built as part of the installation process!</p>
</div>
</div>
<p>For bonus points, replace <code>nimpretty</code> with a symlink to <code>nph</code> - similar
command line options are supported ;)</p>
<h2 id="editor-integration"><a class="header" href="#editor-integration">Editor integration</a></h2>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=NimLang.nimlang">VSCode</a> (<code>ext install NimLang.nimlang</code>) extension via <a href="https://github.com/nim-lang/langserver/">nimlangserver</a> that supports <code>nph</code> out of the box</li>
<li><a href="https://github.com/sbdchd/neoformat">NeoVim</a> - Install <strong>neoformat</strong> in your neovim setup then add the nim formating option with <strong>nph</strong> with this option in init.vim <code>let g:neoformat_enabled_nim = ['nph']</code></li>
<li><a href="https://github.com/foxoman/zed-nim">Zed Editor</a> - Use this in your editor settings</li>
</ul>
<pre><code>&quot;languages&quot;: {
    &quot;Nim&quot;: {
      &quot;formatter&quot;: {
        &quot;external&quot;: {
          &quot;command&quot;: &quot;nph&quot;,
          &quot;arguments&quot;: [&quot;-&quot;]
        }
      }
    }
  }
</code></pre>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=arnetheduck.vscode-nph">vscode-nph</a> (<code>ext install arnetheduck.vscode-nph</code>) for a formatting-only option for the official Nim extension.</li>
</ul>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous integration</a></h2>
<p>Check out the <a href="https://github.com/arnetheduck/nph-action">companion Github Action</a> for a convenient CI option!</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/arnetheduck/nph//edit/master/docs/src/installation.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<pre><code class="language-sh"># Format the given files in-place
nph file0.nim file1.nim

# Format the given files, writing the formatted code to /tmp
nph file0.nim file1.nim --outdir:/tmp

# Format an entire directory
nph src/

# Use --check to verify that a file is formatted correctly as `nph` would - useful in CI
nph --check somefile.nim || echo &quot;Not formatted!&quot;

# Show a diff of what would change without modifying files
nph --diff somefile.nim

# You can format stuff as part of a pipe using `-` as input:
echo &quot;echo 1&quot; | nph -
</code></pre>
<h2 id="configuration-file"><a class="header" href="#configuration-file">Configuration file</a></h2>
<p>You can configure <code>nph</code> using a <code>.nph.toml</code> file in your project root. CLI
options override config file settings.</p>
<pre><code class="language-toml"># Completely replace default exclusions with your own patterns
exclude = [
  &quot;build&quot;,
  &quot;dist&quot;,
]

# Add to default exclusions (recommended - doesn't lose the defaults)
extend-exclude = [
  &quot;tests/fixtures&quot;,
  &quot;vendor&quot;,
]

# Customize which files to include (default: \.nim(s|ble)?$)
include = [
  &quot;\.nim$&quot;,
  &quot;\.nims$&quot;,
]
</code></pre>
<h3 id="default-exclusions"><a class="header" href="#default-exclusions">Default exclusions</a></h3>
<p>By default, <code>nph</code> excludes common directories that typically don't contain
source code:</p>
<ul>
<li><code>.git</code>, <code>.hg</code>, <code>.svn</code> - version control</li>
<li><code>.nimble</code>, <code>nimcache</code> - Nim build artifacts</li>
<li><code>.vscode</code>, <code>.idea</code> - editor directories</li>
<li><code>__pycache__</code>, <code>.mypy_cache</code>, <code>.pytest_cache</code> - Python artifacts</li>
<li><code>.nox</code>, <code>.tox</code>, <code>.venv</code>, <code>venv</code>, <code>.eggs</code> - Python environments</li>
<li><code>node_modules</code> - JavaScript dependencies</li>
<li><code>_build</code>, <code>buck-out</code>, <code>build</code>, <code>dist</code> - common build directories</li>
</ul>
<p>Use <code>extend-exclude</code> to add to these defaults, or <code>exclude</code> to replace them
entirely.</p>
<h2 id="cli-options"><a class="header" href="#cli-options">CLI options</a></h2>
<h3 id="filtering-options"><a class="header" href="#filtering-options">Filtering options</a></h3>
<h4 id="--excludepattern"><a class="header" href="#--excludepattern"><code>--exclude:pattern</code></a></h4>
<p>Completely replaces the default exclusion patterns with your own regex pattern.
Can be specified multiple times.</p>
<pre><code class="language-sh"># Only exclude the build directory
nph --exclude:build src/
</code></pre>
<h4 id="--extend-excludepattern"><a class="header" href="#--extend-excludepattern"><code>--extend-exclude:pattern</code></a></h4>
<p>Adds a regex pattern to the default exclusions. Can be specified multiple times.
This is typically more useful than <code>--exclude</code> since you keep the sensible
defaults.</p>
<pre><code class="language-sh"># Exclude vendor directory in addition to defaults
nph --extend-exclude:vendor src/
</code></pre>
<h4 id="--includepattern"><a class="header" href="#--includepattern"><code>--include:pattern</code></a></h4>
<p>Only format files matching this regex pattern. Can be specified multiple times.
Default is <code>\.nim(s|ble)?$</code>.</p>
<pre><code class="language-sh"># Only format .nim files (not .nims or .nimble)
nph --include:'\.nim$' src/
</code></pre>
<p><strong>Note</strong>: Files passed explicitly on the command line bypass all filtering
(matching Black's behavior):</p>
<pre><code class="language-sh"># This WILL format vendor/foo.nim even if vendor is excluded
nph vendor/foo.nim
</code></pre>
<h3 id="diff-and-check-options"><a class="header" href="#diff-and-check-options">Diff and check options</a></h3>
<h4 id="--diff"><a class="header" href="#--diff"><code>--diff</code></a></h4>
<p>Show a unified diff of formatting changes without modifying files. Useful for
previewing changes or in CI to see what would be reformatted.</p>
<pre><code class="language-sh">nph --diff src/myfile.nim
</code></pre>
<p>Exit code is 0 even if changes are found (informational mode). Combine with
<code>--check</code> to make it fail on changes.</p>
<h4 id="--check"><a class="header" href="#--check"><code>--check</code></a></h4>
<p>Check if files are formatted correctly without modifying them. Exits with code 1
if any file would be reformatted. Perfect for CI pipelines.</p>
<pre><code class="language-sh">nph --check src/
</code></pre>
<p>Can be combined with <code>--diff</code> to both show changes and fail:</p>
<pre><code class="language-sh">nph --check --diff src/
</code></pre>
<h4 id="--color----no-color"><a class="header" href="#--color----no-color"><code>--color</code> / <code>--no-color</code></a></h4>
<p>Enable or disable colored diff output. Only works with <code>--diff</code>. Default is
<code>--no-color</code>.</p>
<pre><code class="language-sh"># Show colored diff
nph --diff --color src/myfile.nim

# Explicitly disable color
nph --diff --no-color src/myfile.nim
</code></pre>
<h3 id="other-options"><a class="header" href="#other-options">Other options</a></h3>
<h4 id="--configfile"><a class="header" href="#--configfile"><code>--config:file</code></a></h4>
<p>Specify a config file to use. Default is <code>.nph.toml</code> if it exists.</p>
<pre><code class="language-sh">nph --config:custom.toml src/
</code></pre>
<h2 id="disabling-formatting-locally"><a class="header" href="#disabling-formatting-locally">Disabling formatting locally</a></h2>
<p>You can mark a code section with <code>#!fmt: off</code> and <code>#!fmt: on</code> to disable formatting locally:</p>
<pre><code class="language-nim">proc      getsFormatted(a, b : int    ) = discard

#!fmt: off
let
  myHandFormattedList
        :
   array[3, int]
 =
    [1, 2, 3]

#!fmt: on
proc hanging(indent: int,
             isUgly = true) = discard
</code></pre>
<p>To disable formatting for a whole file, simply put <code>#!fmt: off</code> on top!</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="usage.html#admonition-note"></a></p>
</div>
<div>
<p><em>Note</em> Internally, <code>#!fmt: off</code> makes nph treat the section as a big multi-line
comment that it copies over to the formatted code - as such, you must be careful
with indent and adjust your code to the indent that <code>nph</code> will generate!</p>
</div>
</div>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/arnetheduck/nph//edit/master/docs/src/usage.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="the-nph-style"><a class="header" href="#the-nph-style">The <code>nph</code> style</a></h1>
<p>As outlined in the <a href="./introduction.html#priorities">introduction</a>, <code>nph</code> strives
to maintain correctness and consistency across various language constructs with
a preference for styles that work well for collaboration.</p>
<p>This section of the book documents some of the style choices and why they were
made.</p>
<ul>
<li><a href="style.html#overview">Overview</a></li>
<li><a href="style.html#lists">Lists</a>
<ul>
<li><a href="style.html#parameter-lists">Parameter lists</a></li>
<li><a href="style.html#infix-operators">Infix operators</a></li>
</ul>
</li>
<li><a href="style.html#expressions">Expressions</a></li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><code>nph</code> generally approaches formatting by considering several choices of
formatting and choosing a reasonable one based on a number of heuristics.</p>
<p>To get an idea what the format looks like, here's a typical proc definition -
everything fits on one line, nice!</p>
<pre><code class="language-nim">proc function(par0: SomeType): bool =
  ...
</code></pre>
<p>If we add more arguments, it starts getting long - nph will try with a version
where the arguments sit on a line of their own:</p>
<pre><code class="language-nim">proc function(
    par0: SomeType, par1: SomeType
): bool =
  ...
</code></pre>
<p>The above idea extends to most formatting: if something is simple, format it in
a simple way - if not, use a bit of style to break down what's going on into
more easily consumable pieces - here's a function with several information-dense
parameters and a pragma:</p>
<pre><code class="language-nim">proc function(
    par0: SomeType,
    par1, par2: SomeOtherType,
    par3 = default(SomeType),
): bool {.inline.} =
  ...
</code></pre>
<div id="admonition-example-styling" class="admonition admonish-info">
<div class="admonition-title">
<p>Example styling</p>
<p><a class="admonition-anchor-link" href="style.html#admonition-example-styling"></a></p>
</div>
<div>
<p>The examples are illustrative and not based on exact rendering semantics - in
particular, a different line length was used to make the point</p>
</div>
</div>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Lists appear frequently in source code: import modules, parameter lists, arrays
and sequence initializers, function call parameters, etc etc.</p>
<p>Generally, list rendering is done according to a number of heuristics, striving
to balance information density with the use of available screen space.</p>
<p>If the whole list fits on the current line, it is rendered in-place. Short
sequences, single-parameter functions etc usually fit into this category:</p>
<pre><code class="language-nim">import dir/module

const v = [1, 2, 3]

type T = proc(a, b: int)
</code></pre>
<p>If it doesnt fit from the current position, we try fitting it in one line on a
new line - this frequently happens with parameter lists and constants where the
name takes up space</p>
<pre><code class="language-nim">import
  dir/[module1, module2, module3, module4]

const mylongvariablename =
  [100000000, 200000000, 300000000]

proc function(
  param0: int, param1: int, param2: int
)
</code></pre>
<p>If the list still doesn't fit on a single line, we look at the contents to
choose between two styles.</p>
<p>If it contains complex complex values, we render one value per row - this
happens most often for function parameters and other information-dense constructs.</p>
<pre><code class="language-nim">import
  dir/[module1, module2, module3],
  dir2/[
    module4, module5, module6, module7,
    module8, module9,
  ]

let myVariable = [
  functionCall(a, b, c),
  functionCall(a, b, c, d),
]

functionCall(
  functionCall(a, b, c),
  functionCall(a, b, c, d),
)
</code></pre>
<div id="admonition-extra-separator" class="admonition admonish-info">
<div class="admonition-title">
<p>Extra separator</p>
<p><a class="admonition-anchor-link" href="style.html#admonition-extra-separator"></a></p>
</div>
<div>
<p>In the long style, we'll insert an extra separator at the end where permissible -
this makes it easier to reorder entries and reduces git conflicts!</p>
</div>
</div>
<p>For simple values, we use a compact style that fits several items per row:</p>
<pre><code class="language-nim">const values = [
  10000000, 2000000000, 3000000000,
  40000000, 5000000000,
]

functionCall(
  10000000, 2000000000, 3000000000,
  40000000, 5000000000,
)
</code></pre>
<div id="admonition-what-is-simple" class="admonition admonish-info">
<div class="admonition-title">
<p>What is simple?</p>
<p><a class="admonition-anchor-link" href="style.html#admonition-what-is-simple"></a></p>
</div>
<div>
<ul>
<li>literals (<code>2</code>, <code>&quot;string&quot;</code> etc)</li>
<li>simple identifiers (<code>myvar</code> etc)</li>
<li>dot expressions of the the above (<code>myObject.field</code>)</li>
</ul>
</div>
</div>
<h3 id="parameter-lists"><a class="header" href="#parameter-lists">Parameter lists</a></h3>
<p>Parameter lists, such as function parameters and generics, are rendered using
the above list style. In the AST, each parameter group is made up of 3
components: one or more names, a type and a default.</p>
<p>If both type and default are missing, we disambiguate parsing multiple names and
groups using a <code>;</code>.</p>
<pre><code class="language-nim"># Usually we can use comma to separate items
proc f(a, b: int, c: float)

# A semicolon is necessary to ensure `T` is interpreted as a type and not part
# of the `v: static int` identifier group
proc g[T; v: static int]

# Semicolons are also significant for type-less parameters - the following two
# templates parse to different ASTs:
template weare(a; b) = discard
template notthesame(a, b) = discard

# Semicolons cannot be used at all for inline procedures:
proc f(
  myParameter = 0,
  callback: SomeCallback = proc() =
    discard
  ,
  nextParameter = 1,
)
</code></pre>
<h3 id="infix-operators"><a class="header" href="#infix-operators">Infix operators</a></h3>
<p><code>nph</code> puts spaces around infix operators such as <code>and</code> and <code>..</code>.</p>
<p>Although NEP1 suggests not having spaces around <code>..</code> and <code>..&lt;</code> in particular,
this creates an exception to the normal infix spacing rules.</p>
<p>In spite of this recommendation, lots of code out there maintains spaces around
the operators which makes decision based on &quot;existing practice&quot; hard.</p>
<p>Adding to the complexity is in order to not break the AST, one would have to
take care to remove the spaces only in cases where the infix is not followed by
another operator (such as <code>-</code>) - this means that we <em>sometimes</em> have to put
spaces around these infixes and sometimes not, leading to irregularity.</p>
<p>Since there's no consensus in existing code at the time of writing, the rule is
irregular and causes implementation complexity, <code>nph</code> formats <code>..</code> and <code>..&lt;</code>
with spaces.</p>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>Expressions appear in many places, such as after certain keywords (<code>return</code>,
<code>yield</code>), as part of control flows (<code>if</code>, <code>while</code>), in assignments etc.</p>
<p>Whenever possible, <code>nph</code> will try to keep the full expression on a single line:</p>
<pre><code class="language-nim">let myvariable = shortexpression(abc)
</code></pre>
<p>If this is not possible, the second preference is to move the whole expression
to a new line, assuming it fits:</p>
<pre><code class="language-nim">let myvariable =
  someevenlongerexpression(abc, def)
</code></pre>
<p>If the expression still doesn't fit, we'll split it up on multiple lines:</p>
<pre><code class="language-nim">let myvariable = someevenlongerexpression(
  aaa, bbb, ccc, ddd
)
</code></pre>
<p>Certain expressions linked by related keywords that don't fit on a single line
will also be moved to a new line - for example, a multi-line <code>if</code>/<code>else</code> nested
in a <code>return</code> will be lined up like so:</p>
<pre><code class="language-nim">return
  if condition:
    complex(call)
  else:
    alsocomplex(call)
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/arnetheduck/nph//edit/master/docs/src/style.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="why-use-a-formatter"><a class="header" href="#why-use-a-formatter">Why use a formatter?</a></h2>
<p>A formatter removes the tedium of manually adding structure to code to make it
more readable - overlong lines, inconsistent indentation, lack of visual
structure and other small distractions quickly nibble away at the mental budget
available for writing code while a formatter solves this and many other things
at the press of a button.</p>
<p>When you work with others, debates and nitpicking over style go away and
collaborative efforts can focus on substance instead.</p>
<p>Finally, the code is likely to look better - manually formatting code takes a
lot of effort which ultimately can be spent better elsewhere - as such, poorly
formatted code ends up being more common than not.</p>
<h2 id="but-ive-spent-a-significant-part-of-my-life-realigning-code-and-now-its-lost"><a class="header" href="#but-ive-spent-a-significant-part-of-my-life-realigning-code-and-now-its-lost">But I've spent a significant part of my life realigning code and now it's lost!</a></h2>
<p>https://en.wikipedia.org/wiki/Sunk_cost</p>
<h2 id="how-do-i-introduce-nph-in-an-existing-codebase"><a class="header" href="#how-do-i-introduce-nph-in-an-existing-codebase">How do I introduce <code>nph</code> in an existing codebase?</a></h2>
<p>Assuming <code>git</code> is used, format all code using <code>nph</code>, put it in a single commit
and add a CI rule to ensure that future commits are all formatted using the same
<code>nph</code> version.</p>
<p>Formatting commits can be ignored for the purpose of <code>git blame</code> by adding a
file named <code>.git-blame-ignore-revs</code> containing the formatted source code to the
root of the project:</p>
<pre><code class="language-sh">cd myproject

# Format all source code with nph
git ls-files | grep &quot;.nim$&quot; | xargs -n1 nph

# Create a single commit with all changes
git commit -am &quot;Formatted with nph $(nph --version)&quot;

# Record the commit hash in the blame file
echo &quot;# Formatted with nph $(nph --version)&quot; &gt;&gt; .git-blame-ignore-revs
echo $(git rev-parse HEAD) &gt;&gt; .git-blame-ignore-revs
</code></pre>
<p>then configure git to use it:</p>
<pre><code class="language-sh">git config --global blame.ignoreRevsFile .git-blame-ignore-revs
</code></pre>
<p>The same strategy can be used when upgrading <code>nph</code> to a new version that
introduces formatting changes.</p>
<h2 id="nph-complains-about-my-code"><a class="header" href="#nph-complains-about-my-code"><code>nph</code> complains about my code!</a></h2>
<p>One of several things could have happened:</p>
<ul>
<li>The code was not valid enough - <code>nph</code> can only parse valid Nim grammar and
while it would be nice to handle partially formatted stuff gracefully, we're
not there yet.</li>
<li>The parser has a bug and is unable to parse valid Nim code
<ul>
<li>Probably you can move some comments around to make it work!</li>
</ul>
</li>
<li>the formatter has a bug and the resulting formatting is invalid
<ul>
<li>Probably you can move some comments around to make it work!</li>
</ul>
</li>
<li>the AST equivalence checker complains
<ul>
<li>This often happens in complex expressions such as <code>do</code>  and parenthesis used
for indent purposes where the Nim grammar has ambiguities and parsing
complexity - it can usually be worked around by simplifying complex
expressions, introducing a template or similar</li>
<li>It could also be that the AST checker is too strict - the Nim parser will
generate different AST:s depending on whitespace even if semantically there
is no difference</li>
</ul>
</li>
</ul>
<p>Regardless of what happened, <code>nph</code> takes the conservative approach and retains
the original formatting!</p>
<p>If you have time, try to find the offending code snippet and submit an issue.</p>
<h2 id="why-the-cited-formatters-in-particular"><a class="header" href="#why-the-cited-formatters-in-particular">Why the cited formatters in particular?</a></h2>
<ul>
<li><code>black</code> because of our syntactic similarity with Python and its
<a href="https://black.readthedocs.io/en/stable/the_black_code_style/index.html#stability-policy">stability policy</a></li>
<li><code>prettier</code> for its wisdom in how formatting <a href="https://prettier.io/docs/en/option-philosophy">options</a>
are approached and for the closeness to user experience of its developers</li>
<li><code>clang-format</code> for being the formatter that made me stop worrying about
formatting
<ul>
<li>its secret sauce was treating formatting as a balancing of priorities rather
than a mechanical stringification using a <a href="https://youtu.be/s7JmdCfI__c?t=640">lowest-penalty</a>
algorithm</li>
</ul>
</li>
</ul>
<h2 id="what-is-meant-by-consistency"><a class="header" href="#what-is-meant-by-consistency">What is meant by consistency?</a></h2>
<ul>
<li>Similar constructs are formatted with similar rules
<ul>
<li>Does it look like a list? Format it with list-like rules regardless if
its a parameter list, array of values or import list</li>
</ul>
</li>
<li>Original styling is generally not preserved - instead, the formatting is based
on the semantic structure of the program</li>
<li>Spacing emphasizes structure and control flow to help you read the code</li>
</ul>
<p><code>nph</code> makes your code consistent without introducing hobgoblins in your mind!</p>
<h2 id="why-are-there-no-options"><a class="header" href="#why-are-there-no-options">Why are there no options?</a></h2>
<p>The aim of <code>nph</code> is to create a single consistent style that allows you to
focus on programming while <code>nph</code> takes care of the formatting, even across
different codebases and authors.</p>
<p>Consistency helps reading speed by removing unique and elaborate formatting
distractions, allowing you, the experienced programmer, to derive structural
information about the codebase at a glance.</p>
<p>The style might feel unfamiliar in the beginning - this is fine and not a reason
to panic - a few weeks from now, you'll forget you ever used another one.</p>
<h2 id="do-you-accept-style-suggestions-and-changes"><a class="header" href="#do-you-accept-style-suggestions-and-changes">Do you accept style suggestions and changes?</a></h2>
<p>Yes! The project is still in its early phase meaning that the style is not yet
set in stone.</p>
<p>To submit a proposal, include some existing code, how you'd like it to be
formatted and an option-free algorithm detailing how to achieve it and how the
outcome relates to the above styling priorities.</p>
<p>When in doubt, look at what other opinionated formatters have done and link to
it!</p>
<p>Eventually, the plan is to adopt a <a href="https://black.readthedocs.io/en/stable/the_black_code_style/index.html#stability-policy">stability policy</a>
similar to <code>black</code>, meaning that style changes will still be accepted, but
introduced only rarely so that you don't have to worry about massive PR-breaking
formatting diffs all the time.</p>
<h2 id="why-does-the-formatting-code-look-an-awful-lot-like-the-nim-compiler-renderer"><a class="header" href="#why-does-the-formatting-code-look-an-awful-lot-like-the-nim-compiler-renderer">Why does the formatting code look an awful lot like the Nim compiler renderer?</a></h2>
<p>Because it is based on it, of course! As a starting point this is fine but the
code would benefit greatly from being rewritten with a dedicated formatting
AST - and here we are.</p>
<h2 id="should-it-be-upstreamed"><a class="header" href="#should-it-be-upstreamed">Should it be upstreamed?</a></h2>
<p>Maybe parts - feel free to make PR:s to the Nim repo from this codebase! That
said, the aim of a compiler is to compile while a formatter formats - we are not
the same.</p>
<h2 id="what-about-nimpretty"><a class="header" href="#what-about-nimpretty">What about <code>nimpretty</code>?</a></h2>
<p><code>nimpretty</code> formats tokens, not the AST. Use whichever you like better, but keep
a backup if you don't use <code>nph</code> :)</p>
<h2 id="why-88-characters"><a class="header" href="#why-88-characters">Why 88 characters?</a></h2>
<p>This is an experiment.</p>
<p>Astute and experienced programmers have noticed two things: longer variable
names aren't that bad and monitors have gotten bigger since the 80 standard was
set.</p>
<p>Going beyond allows code that uses descriptive names to look better - how much
extra is needed here is an open question but 10% seems like a good start for a
language like Nim which defaults to 2-space significant indent and a naive
module system that encourages globally unique identifiers with longer names.</p>
<p>Automated formatting keeps most code well below this limit but the extra 10%
allows gives it some lenience - think of it as those cases where a prorgammer
would use their judgement and common sense to override a style guide
recommendation.</p>
<h2 id="what-about-comments"><a class="header" href="#what-about-comments">What about comments?</a></h2>
<p>Comments may appear in many different places that are not represented in the
Nim AST. When <code>nph</code> reformats code, it may have to move comments around in order
to maintain line lengths and introduce or remove indentation.</p>
<p><code>nph</code> uses heuristics to place comments into one of several categories which
broadly play by similar rules that code does - in particular, indentation is
used to determine &quot;ownership&quot; over the comment.</p>
<p>The implementation currently tracks several comment categories:</p>
<ul>
<li>comment statement nodes - comments that appear with regular indent in
statement list contexts (such as the body of a <code>proc</code>) as represented as such,
ie as statement nodes and get treated similar to how regular code would</li>
<li>node attachments - comments that are anchored to an AST node depending on
their location in the code relative to that node:
<ul>
<li>prefix - anything leading up to a particular AST node - for example less
indented or otherwise appearing before the node</li>
<li>mid - at midpoints in composite nodes - between the <code>:</code> and the body of an
<code>if</code> for example</li>
<li>postfix - appearing after the node, meaning on the same line or more
indented than the node</li>
</ul>
</li>
</ul>
<p>When rendering the code, <code>nph</code> will use these categories to guide where the
comment text should go, maintaining comment output in such a way that parsing
the file again results in equivalent comment placement.</p>
<h2 id="how-are-blank-lines-handled"><a class="header" href="#how-are-blank-lines-handled">How are blank lines handled?</a></h2>
<p>Coming up with a fully automatic rendering of blank lines is tricky because they
are often used to signal logical groupings of code for which no other mechanism
exists to represent them.</p>
<p><code>nph</code> current will:</p>
<ul>
<li>generally retain blank space in code but normalise it to a single line</li>
<li>insert blanks around complex statements</li>
</ul>
<p>This strategy is expected to evolve over time, including the meaning of
&quot;complex&quot;.</p>
<h2 id="what-features-will-likely-not-be-added"><a class="header" href="#what-features-will-likely-not-be-added">What features will likely not be added?</a></h2>
<ul>
<li>formatting options - things that change the way the formatting is done for
aesthetic reasons - exceptions here might include options that increase
compatiblity (for example with older Nim versions)</li>
<li>semantic refactoring - the focus is on style only
<ul>
<li><code>import</code> reording in particular changes order in which code executes!</li>
</ul>
</li>
</ul>
<h2 id="whats-with-the-semicolons"><a class="header" href="#whats-with-the-semicolons">What's with the semicolons?</a></h2>
<p>Nim's grammar unfortunately allows the use of either <code>,</code> or <code>;</code> in some places
with a subtly different AST being produced which <em>sometimes</em> has a semantic
impact.</p>
<p>Parameters in particular are parsed using identifier groups where each group
consists of one or more names followed by an option type and default.</p>
<p>Names are separated by <code>,</code> - if the type and default are missing, a <code>;</code> is
needed to start a new group or the name would be added to the previous group
if a <code>;</code> was used originally to create a new group.</p>
<p>However, if the group has a default, <code>;</code> cannot be parsed because it's swallowed
in certain cases (<code>proc</code> implementations in particular) by the default value
parsing.</p>
<p>As such, <code>nph</code> will normalise usage of <code>,</code> and <code>;</code> to:</p>
<ul>
<li>Use <code>,</code> after a group that has a type and/or default</li>
<li>Use <code>;</code> otherwise</li>
</ul>
<p>Regardless, you can usually type either and <code>nph</code> will clean it up in such a way
that the AST remains unambiguous, compatible with all possible values and in
line with the common expectation that <code>,</code> is used where possible.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/arnetheduck/nph//edit/master/docs/src/faq.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="testbench"><a class="header" href="#testbench">Testbench</a></h1>
<p>The testbench of <code>nph</code> is split into two parts:</p>
<ul>
<li>before/after tests in <code>tests/</code> - these cover the basics as well as an assortment
of unusually formatted code in the wild - changes and additions to the
formatting rules usually find representation here</li>
<li>playground - formatting of several large-ish projects</li>
</ul>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>Unit tests with before/after stored in the repo and checked by CI - should
be extended with each proposal to change the formatting rules:</p>
<pre><code class="language-sh"># Run the tests
nimble f
</code></pre>
<h2 id="playground"><a class="header" href="#playground">Playground</a></h2>
<p>The playground can be used to test two important scenarios: formatting a &quot;raw&quot;
hand-formatted codebase and re-formatting a codebase already formatted by <code>nph</code>.</p>
<pre><code class="language-sh"># Format an existing codebase and show the diff against the upstream version -
# this will clone a clean version of the project and format it with `nph`
nimble play

# Same as above, but commit the changes to establish a starting point for making
# changes to the formatting algo
nimble replay

# Format the current state of the playground without resetting the repository -
# together with `replay`, it allows checking the diff of a suggested formatting
# change - oddities found here should be brought back to the regular test suite
nimble again
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/arnetheduck/nph//edit/master/docs/src/test.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="updating-this-book"><a class="header" href="#updating-this-book">Updating this book</a></h1>
<p>The book is built using <a href="https://github.com/rust-lang/mdBook">mdBook</a>, and published to gh-pages using a github action.</p>
<pre><code class="language-bash"># Install or update tooling (make sure you add &quot;~/.cargo/bin&quot; to PATH):
cargo install mdbook --version 0.4.36
cargo install mdbook-toc --version 0.14.1
cargo install mdbook-open-on-gh --version 2.4.1
cargo install mdbook-admonish --version 1.14.0

# Edit book and view through local browser
mdbook serve
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/arnetheduck/nph//edit/master/docs/src/book.md">Edit this page on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
